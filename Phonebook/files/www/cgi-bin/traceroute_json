#!/bin/sh
# traceroute_json - Traceroute JSON Endpoint
# Performs a live traceroute to the specified IP address
# Usage: curl "http://node/cgi-bin/traceroute_json?ip=10.51.55.233"

# Set Content-Type header
echo "Content-Type: application/json; charset=utf-8"
echo ""

# Parse query string for IP parameter
if [ -n "$QUERY_STRING" ]; then
    TARGET_IP=$(echo "$QUERY_STRING" | grep -o "ip=[^&]*" | cut -d'=' -f2)
fi

# Validate IP parameter
if [ -z "$TARGET_IP" ]; then
    cat <<'EOF'
{
  "error": "Missing IP parameter. Usage: /cgi-bin/traceroute_json?ip=<target_ip>",
  "hops": []
}
EOF
    exit 0
fi

# Measure localhost loopback delay
LOCALHOST_NAME=$(cat /proc/sys/kernel/hostname 2>/dev/null || echo "localhost")
LOCALHOST_RTT=$(ping -c 1 -W 1 127.0.0.1 2>/dev/null | grep "time=" | sed 's/.*time=\([0-9.]*\).*/\1/')
[ -z "$LOCALHOST_RTT" ] && LOCALHOST_RTT="0.0"

# Perform traceroute using ICMP
# -I: Use ICMP ECHO instead of UDP
# -m: Max hops (30)
# -w: Timeout per hop (2 seconds)
# -n: Don't resolve hostnames (we'll do it ourselves for .local.mesh)
TRACEROUTE_OUTPUT=$(traceroute -I -m 30 -w 2 -n "$TARGET_IP" 2>&1)

# Check if traceroute succeeded
if [ $? -ne 0 ]; then
    cat <<EOF
{
  "error": "Traceroute failed: $TRACEROUTE_OUTPUT",
  "target_ip": "$TARGET_IP",
  "hops": []
}
EOF
    exit 0
fi

# Parse traceroute output and convert to JSON
# Format: hop_number  ip_address  rtt1 ms  rtt2 ms  rtt3 ms
# We'll extract: hop number, IP, and average RTT

echo "{"
echo "  \"target_ip\": \"$TARGET_IP\","
echo "  \"hops\": ["

# Add localhost as hop 0
echo "    {"
echo "      \"hop\": 0,"
echo "      \"ip\": \"127.0.0.1\","
echo "      \"hostname\": \"$LOCALHOST_NAME\","
echo "      \"rtt_ms\": $LOCALHOST_RTT,"
echo "      \"timeout\": false"
echo -n "    }"

FIRST_HOP=false
echo "$TRACEROUTE_OUTPUT" | tail -n +2 | while IFS= read -r line; do
    # Skip empty lines
    [ -z "$line" ] && continue

    # Extract hop number (first field)
    HOP_NUM=$(echo "$line" | awk '{print $1}')

    # Check if this is a timeout hop (* * *)
    if echo "$line" | grep -q "\* \* \*"; then
        # Timeout hop
        if [ "$FIRST_HOP" = false ]; then
            echo ","
        fi
        echo "    {"
        echo "      \"hop\": $HOP_NUM,"
        echo "      \"ip\": \"*\","
        echo "      \"hostname\": \"*\","
        echo "      \"rtt_ms\": 0,"
        echo "      \"timeout\": true"
        echo -n "    }"
        FIRST_HOP=false
        continue
    fi

    # Extract IP address (second field, might be in parentheses)
    IP=$(echo "$line" | awk '{print $2}' | tr -d '()')

    # Skip if no IP found
    [ -z "$IP" ] && continue

    # Extract RTT values (look for numbers followed by 'ms')
    RTT_VALUES=$(echo "$line" | grep -o "[0-9.]*\s*ms" | grep -o "[0-9.]*")

    # Calculate average RTT
    if [ -n "$RTT_VALUES" ]; then
        RTT_COUNT=$(echo "$RTT_VALUES" | wc -l)
        RTT_SUM=$(echo "$RTT_VALUES" | awk '{sum+=$1} END {print sum}')
        RTT_AVG=$(awk "BEGIN {printf \"%.2f\", $RTT_SUM / $RTT_COUNT}")
    else
        RTT_AVG="0.00"
    fi

    # Try reverse DNS lookup (take only first line and sanitize)
    HOSTNAME=$(nslookup "$IP" 2>/dev/null | grep "name =" | head -1 | awk '{print $4}' | sed 's/\.$//' | tr -d '\n\r\t')
    [ -z "$HOSTNAME" ] && HOSTNAME="$IP"

    # Remove .local.mesh suffix if present
    HOSTNAME=$(echo "$HOSTNAME" | sed 's/\.local\.mesh$//')

    # Output JSON for this hop
    if [ "$FIRST_HOP" = false ]; then
        echo ","
    fi
    echo "    {"
    echo "      \"hop\": $HOP_NUM,"
    echo "      \"ip\": \"$IP\","
    echo "      \"hostname\": \"$HOSTNAME\","
    echo "      \"rtt_ms\": $RTT_AVG,"
    echo "      \"timeout\": false"
    echo -n "    }"
    FIRST_HOP=false
done

echo ""
echo "  ]"
echo "}"
