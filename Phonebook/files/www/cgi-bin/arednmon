#!/bin/sh
# AREDNmon - AREDN Mesh Network Monitor
# Displays network monitoring results from automated bulk test cycles
# The bulk test runs automatically every UAC_TEST_INTERVAL_SECONDS (default: 600s)
# Usage: curl "http://node/cgi-bin/arednmon"

echo "Content-Type: text/html; charset=utf-8"
echo ""

# Get configuration
CONFIG_FILE="/etc/phonebook.conf"
TEST_INTERVAL=$(grep "^UAC_TEST_INTERVAL_SECONDS=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
TEST_INTERVAL=${TEST_INTERVAL:-60}

# HTML Header
cat <<'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>AREDNmon - Network Monitor</title>
    <meta http-equiv="refresh" content="30">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .info {
            background-color: #e7f3fe;
            border-left: 4px solid #2196F3;
            padding: 10px;
            margin-bottom: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        th {
            background-color: #4CAF50;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        td {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .online {
            color: #4CAF50;
            font-weight: bold;
        }
        .offline {
            color: #f44336;
            font-weight: bold;
        }
        .no-dns {
            color: #999;
        }
        .disabled {
            color: #999;
        }
        .rtt-good {
            color: #4CAF50;
        }
        .rtt-medium {
            color: #FF9800;
        }
        .rtt-poor {
            color: #f44336;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .error {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px;
            margin: 20px 0;
            color: #c62828;
        }
        .progress-container {
            background-color: #f0f0f0;
            border-radius: 8px;
            height: 30px;
            margin: 10px 0;
            overflow: hidden;
            position: relative;
        }
        .progress-bar {
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            height: 100%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            color: #333;
            z-index: 1;
        }
        /* Health Panel Styles */
        .health-panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .health-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .health-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
        }
        .health-score {
            font-size: 2em;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 8px;
        }
        .health-score.excellent { background-color: #4CAF50; color: white; }
        .health-score.good { background-color: #8BC34A; color: white; }
        .health-score.degraded { background-color: #FF9800; color: white; }
        .health-score.critical { background-color: #f44336; color: white; }
        .health-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .health-metric {
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        .health-metric-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        .health-metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
        .health-checks {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        .health-check {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .health-check.pass {
            background-color: #C8E6C9;
            color: #2E7D32;
        }
        .health-check.fail {
            background-color: #FFCDD2;
            color: #C62828;
        }
        .health-threads {
            margin-top: 15px;
            font-size: 0.9em;
        }
        .thread-status {
            display: inline-block;
            margin-right: 15px;
            padding: 3px 8px;
            border-radius: 3px;
        }
        .thread-status.responsive {
            background-color: #C8E6C9;
            color: #2E7D32;
        }
        .thread-status.unresponsive {
            background-color: #FFCDD2;
            color: #C62828;
        }
        /* Map Panel Styles */
        .map-panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .map-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }
        #topologyMap {
            width: 100%;
            aspect-ratio: 16 / 9;
            border-radius: 4px;
        }
        .map-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        .map-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        .map-btn:hover {
            background-color: #45a049;
        }
        .map-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .map-legend {
            margin-top: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            font-size: 0.9em;
        }
        /* Traceroute Display Styles */
        .traceroute-panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        .traceroute-panel.visible {
            display: block;
        }
        .traceroute-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }
        .traceroute-content {
            font-family: monospace;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .traceroute-loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .traceroute-hop {
            padding: 5px 0;
            border-bottom: 1px solid #ddd;
        }
        .traceroute-hop:last-child {
            border-bottom: none;
        }
        .traceroute-hop-number {
            display: inline-block;
            width: 40px;
            font-weight: bold;
            color: #2196F3;
        }
        .traceroute-hop-host {
            color: #333;
        }
        .traceroute-hop-rtt {
            color: #4CAF50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>AREDNmon - Network Monitor</h1>
EOF

cat <<'EOF'
    <!-- Software Health Panel -->
    <div class="health-panel" id="healthPanel">
        <div class="health-header">
            <div class="health-title">Software Health Status</div>
        </div>
        <div class="health-metrics">
            <div class="health-metric">
                <div class="health-metric-label">CPU Usage</div>
                <div class="health-metric-value" id="healthCpu">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">Memory Usage</div>
                <div class="health-metric-value" id="healthMemory">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">Uptime</div>
                <div class="health-metric-value" id="healthUptime">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">SIP Service</div>
                <div class="health-metric-value" id="healthSipUsers">-</div>
            </div>
        </div>
        <div class="health-checks" id="healthChecks">
            <!-- Health checks will be populated by JavaScript -->
        </div>
        <div class="health-threads" id="healthThreads">
            <strong>Thread Status:</strong> <span id="threadStatus">Loading...</span>
        </div>
    </div>

    <!-- Network Topology Map -->
    <div class="map-panel" id="mapPanel">
        <div class="map-title">Network Topology Map</div>
        <div id="topologyMap"></div>
        <div class="map-controls">
            <button class="map-btn" id="refreshMapBtn">Refresh Topology</button>
            <span id="mapStatus" style="margin-left: 10px; color: #666;"></span>
        </div>
        <div class="map-legend">
            <strong>Connection Quality (RTT):</strong><br>
            <span style="color: #4CAF50;">━━━ Green</span> - Excellent (&lt;100ms)<br>
            <span style="color: #FF9800;">━━━ Orange</span> - Medium (100-200ms)<br>
            <span style="color: #f44336;">━━━ Red</span> - Poor (&gt;200ms)<br>
            <br>
            <strong>Interaction:</strong> Click any node to highlight the route and show traceroute results below
        </div>
    </div>

    <!-- Traceroute Panel -->
    <div class="traceroute-panel" id="traceroutePanel">
        <div class="traceroute-title" id="tracerouteTitle">Traceroute Results</div>
        <div class="traceroute-content" id="tracerouteContent">
            <div class="traceroute-loading">Click on a node to view traceroute</div>
        </div>
    </div>
EOF

cat <<EOF
    <div id="errorContainer"></div>

    <table>
        <thead>
            <tr>
                <th>Phone Number</th>
                <th>Name</th>
                <th>Ping Status</th>
                <th>Ping RTT (ms)</th>
                <th>Ping Jitter (ms)</th>
                <th>OPTIONS Status</th>
                <th>OPTIONS RTT (ms)</th>
                <th>OPTIONS Jitter (ms)</th>
            </tr>
        </thead>
        <tbody id="results">
            <tr><td colspan="8" class="loading">Loading test results...</td></tr>
        </tbody>
    </table>

    <script>
        // Health data update interval (60 seconds to match local file updates)
        const HEALTH_UPDATE_INTERVAL = 60000;

        // Load and display software health
        async function loadHealthStatus() {
            try {
                const response = await fetch('/cgi-bin/health_status');
                const data = await response.json();

                if (data.error) {
                    return;
                }

                // Update metrics
                document.getElementById('healthCpu').textContent =
                    (data.cpu_pct || 0).toFixed(1) + '%';
                document.getElementById('healthMemory').textContent =
                    (data.mem_mb || 0).toFixed(1) + ' MB';

                // Format uptime
                const uptimeSeconds = data.uptime_seconds || 0;
                const hours = Math.floor(uptimeSeconds / 3600);
                const minutes = Math.floor((uptimeSeconds % 3600) / 60);
                document.getElementById('healthUptime').textContent =
                    hours + 'h ' + minutes + 'm';

                // SIP service metrics
                const users = data.sip_service?.registered_users || 0;
                const entries = data.sip_service?.directory_entries || 0;
                const calls = data.sip_service?.active_calls || 0;
                document.getElementById('healthSipUsers').textContent =
                    users + ' users, ' + calls + ' calls';

                // Update health checks
                const checks = data.checks || {};
                const checksHtml = [
                    { label: 'Memory', pass: checks.memory_stable },
                    { label: 'No Crashes', pass: checks.no_recent_crashes },
                    { label: 'SIP Service', pass: checks.sip_service_ok },
                    { label: 'Phonebook', pass: checks.phonebook_current },
                    { label: 'CPU', pass: checks.cpu_normal }
                ].map(check =>
                    '<span class="health-check ' + (check.pass ? 'pass' : 'fail') + '">' +
                    check.label + ': ' + (check.pass ? '✓' : '✗') + '</span>'
                ).join('');
                document.getElementById('healthChecks').innerHTML = checksHtml;

                // Update thread status
                const threads = data.threads || {};
                const allResponsive = threads.all_responsive;
                let threadHtml = '';

                if (allResponsive) {
                    threadHtml = '<span class="thread-status responsive">All threads responsive ✓</span>';
                } else {
                    // Show individual thread status
                    const threadNames = ['phonebook_fetcher', 'status_updater', 'passive_safety',
                                       'uac_bulk_tester', 'health_reporter'];
                    threadHtml = threadNames
                        .filter(name => threads[name])
                        .map(name => {
                            const thread = threads[name];
                            const responsive = thread.responsive;
                            return '<span class="thread-status ' +
                                   (responsive ? 'responsive' : 'unresponsive') + '">' +
                                   name + ': ' + (responsive ? '✓' : '✗') + '</span>';
                        }).join('');
                }
                document.getElementById('threadStatus').innerHTML = threadHtml;

            } catch (error) {
                console.error('Failed to load health status:', error);
            }
        }

        // Phonebook data (loaded from server)
        let phonebook = {};

        // Load phonebook data with smart caching
        async function loadPhonebook(lastTestUpdate) {
            try {
                // Check if phonebook cache exists (v2 - invalidates old caches after DB structure change)
                const cached = localStorage.getItem('phonebook_cache_v2');
                const cacheTestUpdate = localStorage.getItem('phonebook_cache_test_update_v2');

                // Invalidate cache if test database is newer (phonebook may have changed)
                const cacheValid = cached && cacheTestUpdate &&
                                   parseInt(cacheTestUpdate) >= lastTestUpdate;

                if (cacheValid) {
                    phonebook = JSON.parse(cached);
                    console.log('Using cached phonebook (' + Object.keys(phonebook).length + ' entries)');
                    return;
                }

                // Cache invalid or missing - fetch from server
                console.log('Fetching phonebook from server...');
                const response = await fetch('/cgi-bin/showphonebook');
                const data = await response.json();

                if (data.entries && data.entries.length > 0) {
                    data.entries.forEach(entry => {
                        // Extract phone number without @routing suffix
                        const phoneNumber = entry.telephone.split('@')[0];
                        phonebook[phoneNumber] = entry.name.trim();
                    });

                    // Save to localStorage cache with test database timestamp
                    localStorage.setItem('phonebook_cache_v2', JSON.stringify(phonebook));
                    localStorage.setItem('phonebook_cache_test_update_v2', lastTestUpdate.toString());
                    console.log('Cached phonebook (' + Object.keys(phonebook).length + ' entries) at test update ' + lastTestUpdate);
                }
            } catch (error) {
                console.error('Failed to load phonebook:', error);
            }
        }

        // Get display name for a phone number
        function getDisplayName(phoneNumber) {
            // Strip any @routing suffix from phone number
            const cleanNumber = phoneNumber.split('@')[0];
            return phonebook[cleanNumber] || phoneNumber;
        }

        // Get CSS class for status
        function getStatusClass(status) {
            if (status === 'ONLINE') return 'online';
            if (status === 'OFFLINE') return 'offline';
            if (status === 'NO_DNS' || status === 'NO DNS') return 'no-dns';
            if (status === 'DISABLED') return 'disabled';
            return '';
        }

        // Get CSS class for RTT
        function getRttClass(rtt) {
            if (rtt <= 0) return '';
            if (rtt > 200) return 'rtt-poor';
            if (rtt > 100) return 'rtt-medium';
            return 'rtt-good';
        }

        // Format RTT value
        function formatRtt(value) {
            if (value <= 0) return '-';
            return value.toFixed(2);
        }

        // Load and display test results
        async function loadResults() {
            try {
                const response = await fetch('/cgi-bin/uac_test_db_json');
                const data = await response.json();

                if (data.error) {
                    document.getElementById('errorContainer').innerHTML =
                        '<div class="error">Error: ' + data.error + '</div>';
                    document.getElementById('results').innerHTML =
                        '<tr><td colspan="8" class="loading">No test data available yet</td></tr>';
                    return data.last_update || 0;
                }

                // Update last update time
                if (data.last_update) {
                    const lastUpdate = new Date(data.last_update * 1000);
                    document.getElementById('lastUpdate').textContent = lastUpdate.toLocaleString();
                }

                // Return last_update timestamp for cache validation
                const lastUpdateTimestamp = data.last_update || 0;

                // Build table rows
                const tbody = document.getElementById('results');
                tbody.innerHTML = '';

                if (data.results && data.results.length > 0) {
                    data.results.forEach(result => {
                        const row = document.createElement('tr');
                        const displayName = getDisplayName(result.phone_number);

                        row.innerHTML =
                            '<td>' + result.phone_number + '</td>' +
                            '<td>' + displayName + '</td>' +
                            '<td class="' + getStatusClass(result.ping_status) + '">' + result.ping_status + '</td>' +
                            '<td class="' + getRttClass(result.ping_rtt) + '">' + formatRtt(result.ping_rtt) + '</td>' +
                            '<td>' + formatRtt(result.ping_jitter) + '</td>' +
                            '<td class="' + getStatusClass(result.options_status) + '">' + result.options_status + '</td>' +
                            '<td class="' + getRttClass(result.options_rtt) + '">' + formatRtt(result.options_rtt) + '</td>' +
                            '<td>' + formatRtt(result.options_jitter) + '</td>';

                        tbody.appendChild(row);
                    });
                } else {
                    tbody.innerHTML = '<tr><td colspan="8" class="loading">No test results available</td></tr>';
                }

                return lastUpdateTimestamp;
            } catch (error) {
                console.error('Failed to load results:', error);
                document.getElementById('errorContainer').innerHTML =
                    '<div class="error">Failed to load test results: ' + error.message + '</div>';
                document.getElementById('results').innerHTML =
                    '<tr><td colspan="8" class="loading">Error loading results</td></tr>';
                return 0;
            }
        }

        // Update progress indicator
        function updateProgress(numResults, numTestablePhones) {
            // Show progress only for reachable phones (those marked with * in phonebook)
            const reachablePhones = numTestablePhones || 0;
            const progressPct = reachablePhones > 0 ? Math.min(100, Math.round((numResults / reachablePhones) * 100)) : 0;

            document.getElementById('testProgress').textContent = numResults + ' of ' + reachablePhones + ' phones tested (all reachable telephones only)';
            document.getElementById('progressText').textContent = progressPct + '%';
            document.getElementById('progressBar').style.width = progressPct + '%';
        }

        // ============================================================
        // TOPOLOGY MAP FUNCTIONALITY
        // ============================================================

        let topologyMap = null;
        let topologyData = null;
        let nodeMarkers = {};
        let connectionLines = [];
        let highlightedPath = [];

        // Fetch and display traceroute for a node
        async function fetchTraceroute(targetIp, targetName) {
            const panel = document.getElementById('traceroutePanel');
            const title = document.getElementById('tracerouteTitle');
            const content = document.getElementById('tracerouteContent');

            // Show panel
            panel.classList.add('visible');

            // Update title
            title.textContent = 'Traceroute to ' + targetName + ' (' + targetIp + ')';

            // Show loading
            content.innerHTML = '<div class="traceroute-loading">Running traceroute...</div>';

            try {
                const response = await fetch('/cgi-bin/traceroute_json?ip=' + encodeURIComponent(targetIp));
                const data = await response.json();

                if (data.error) {
                    content.innerHTML = '<div class="error">' + data.error + '</div>';
                    return;
                }

                // Display hops
                if (!data.hops || data.hops.length === 0) {
                    content.innerHTML = '<div class="traceroute-loading">No hops found</div>';
                    return;
                }

                let html = '';
                data.hops.forEach(hop => {
                    if (hop.timeout) {
                        html += '<div class="traceroute-hop">' +
                               '<span class="traceroute-hop-number">' + hop.hop + '</span>' +
                               '<span class="traceroute-hop-host">* * * (timeout)</span>' +
                               '</div>';
                    } else {
                        html += '<div class="traceroute-hop">' +
                               '<span class="traceroute-hop-number">' + hop.hop + '</span>' +
                               '<span class="traceroute-hop-host">' + hop.hostname + ' (' + hop.ip + ')</span>  ' +
                               '<span class="traceroute-hop-rtt">' + hop.rtt_ms.toFixed(2) + ' ms</span>' +
                               '</div>';
                    }
                });

                content.innerHTML = html;

            } catch (error) {
                console.error('Failed to fetch traceroute:', error);
                content.innerHTML = '<div class="error">Failed to fetch traceroute: ' + error.message + '</div>';
            }
        }

        // Initialize Leaflet map
        function initMap() {
            // Switzerland bounds: [45.8, 5.9] to [47.8, 10.5]
            const switzerlandBounds = [
                [45.8, 5.9],  // Southwest corner
                [47.8, 10.5]  // Northeast corner
            ];

            // Create map centered on Switzerland
            topologyMap = L.map('topologyMap', {
                maxBounds: switzerlandBounds,
                maxBoundsViscosity: 1.0  // Prevent panning outside bounds
            }).fitBounds(switzerlandBounds);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 18,
                minZoom: 7  // Prevent zooming out beyond Switzerland
            }).addTo(topologyMap);

            console.log('Topology map initialized');
        }

        // Load topology data from server
        async function loadTopologyData() {
            try {
                const response = await fetch('/cgi-bin/topology_json');
                const data = await response.json();

                if (data.error) {
                    document.getElementById('mapStatus').textContent = data.error;
                    console.log('No topology data available yet');
                    return null;
                }

                topologyData = data;
                document.getElementById('mapStatus').textContent =
                    data.statistics.total_nodes + ' nodes, ' +
                    data.statistics.total_connections + ' connections';

                console.log('Loaded topology:', data.statistics);
                return data;
            } catch (error) {
                console.error('Failed to load topology data:', error);
                document.getElementById('mapStatus').textContent = 'Error loading topology';
                return null;
            }
        }

        // Get color for node type and status
        function getNodeColor(type, status) {
            if (status === 'OFFLINE') {
                return '#9E9E9E';  // Grey for offline
            }
            switch (type) {
                case 'phone': return '#4CAF50';  // Green
                case 'router': return '#FF9800'; // Orange
                default: return '#9E9E9E';       // Gray
            }
        }

        // Get icon for node type and status
        function getNodeIcon(type, status) {
            const color = getNodeColor(type, status);
            return L.divIcon({
                className: 'custom-div-icon',
                html: '<div style="background-color:' + color + '; width: 12px; height: 12px; border-radius: 50%; border: 2px solid white;"></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        // Render topology on map
        function renderTopology(data) {
            if (!topologyMap || !data) {
                return;
            }

            // Clear existing markers and lines
            Object.values(nodeMarkers).forEach(marker => topologyMap.removeLayer(marker));
            connectionLines.forEach(line => topologyMap.removeLayer(line));
            nodeMarkers = {};
            connectionLines = [];

            // Find map bounds
            let bounds = [];

            // Add nodes
            data.nodes.forEach(node => {
                // Skip nodes without location
                if (!node.lat || !node.lon || node.lat === '' || node.lon === '') {
                    return;
                }

                const lat = parseFloat(node.lat);
                const lon = parseFloat(node.lon);

                if (isNaN(lat) || isNaN(lon)) {
                    return;
                }

                bounds.push([lat, lon]);

                // Clean up node name (remove hostname prefix like "mid2.")
                let cleanName = node.name;
                if (cleanName.includes('.')) {
                    const parts = cleanName.split('.');
                    // If first part looks like hostname prefix (lowercase, short), remove it
                    if (parts.length > 1 && parts[0].length < 8 && parts[0] === parts[0].toLowerCase()) {
                        cleanName = parts.slice(1).join('.');
                    }
                }

                // Create marker
                const marker = L.marker([lat, lon], {
                    icon: getNodeIcon(node.type, node.status),
                    title: cleanName
                }).addTo(topologyMap);

                // Add simple popup with just the name
                marker.bindPopup('<strong>' + cleanName + '</strong>');

                // Add click handler for route highlighting and traceroute
                marker.on('click', function() {
                    highlightPathToNode(data, node.ip);
                    fetchTraceroute(node.ip, node.name);
                });

                nodeMarkers[node.ip] = marker;
            });

            // Get color for RTT (same as table color coding)
            function getRttColor(rtt) {
                if (rtt > 200) return '#f44336';  // Red - poor
                if (rtt > 100) return '#FF9800';  // Orange - medium
                return '#4CAF50';                  // Green - good
            }

            // Add connections with color coding and labels
            data.connections.forEach(conn => {
                const fromMarker = nodeMarkers[conn.from];
                const toMarker = nodeMarkers[conn.to];

                if (fromMarker && toMarker) {
                    const color = getRttColor(conn.rtt_avg_ms);

                    const line = L.polyline([
                        fromMarker.getLatLng(),
                        toMarker.getLatLng()
                    ], {
                        color: color,
                        weight: 3,
                        opacity: 0.7
                    }).addTo(topologyMap);

                    // Add tooltip with RTT info
                    line.bindTooltip(
                        'RTT: ' + conn.rtt_avg_ms.toFixed(1) + ' ms' +
                        ' (min: ' + conn.rtt_min_ms.toFixed(1) +
                        ', max: ' + conn.rtt_max_ms.toFixed(1) + ')',
                        { sticky: true, permanent: false }
                    );

                    // Find node types for from and to
                    const fromNode = data.nodes.find(n => n.ip === conn.from);
                    const toNode = data.nodes.find(n => n.ip === conn.to);

                    // Only show RTT label for router-to-router connections
                    const isRouterToRouter = fromNode && toNode &&
                                            fromNode.type === 'router' && toNode.type === 'router';

                    if (isRouterToRouter) {
                        // Add permanent label at midpoint showing RTT
                        const midpoint = [
                            (fromMarker.getLatLng().lat + toMarker.getLatLng().lat) / 2,
                            (fromMarker.getLatLng().lng + toMarker.getLatLng().lng) / 2
                        ];

                        L.marker(midpoint, {
                            icon: L.divIcon({
                                className: 'rtt-label',
                                html: '<div style="background-color: white; padding: 2px 4px; border-radius: 3px; ' +
                                      'font-size: 10px; font-weight: bold; color: ' + color + '; ' +
                                      'border: 1px solid ' + color + ';">' +
                                      conn.rtt_avg_ms.toFixed(1) + 'ms</div>',
                                iconSize: [40, 20],
                                iconAnchor: [20, 10]
                            })
                        }).addTo(topologyMap);
                    }

                    connectionLines.push(line);
                }
            });

            // Don't auto-zoom on render (removed autozoom functionality)

            console.log('Rendered', Object.keys(nodeMarkers).length, 'nodes and',
                       connectionLines.length, 'connections');
        }

        // BFS to find shortest path
        function findShortestPath(data, targetIp) {
            if (!data || !data.source_node) {
                return [];
            }

            const sourceIp = data.source_node.ip;

            // Build adjacency list
            const graph = {};
            data.connections.forEach(conn => {
                if (!graph[conn.from]) graph[conn.from] = [];
                if (!graph[conn.to]) graph[conn.to] = [];
                graph[conn.from].push(conn.to);
                graph[conn.to].push(conn.from); // Bidirectional
            });

            // BFS
            const queue = [[sourceIp]];
            const visited = new Set([sourceIp]);

            while (queue.length > 0) {
                const path = queue.shift();
                const node = path[path.length - 1];

                if (node === targetIp) {
                    return path;
                }

                if (graph[node]) {
                    graph[node].forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push([...path, neighbor]);
                        }
                    });
                }
            }

            return []; // No path found
        }

        // Highlight path to specific node
        function highlightPathToNode(data, targetIp) {
            // Clear previous highlights
            highlightedPath.forEach(line => topologyMap.removeLayer(line));
            highlightedPath = [];

            // Find shortest path
            const path = findShortestPath(data, targetIp);

            if (path.length === 0) {
                console.log('No path found to', targetIp);
                return;
            }

            console.log('Path to', targetIp, ':', path);

            // Draw highlighted path
            for (let i = 0; i < path.length - 1; i++) {
                const fromMarker = nodeMarkers[path[i]];
                const toMarker = nodeMarkers[path[i + 1]];

                if (fromMarker && toMarker) {
                    const line = L.polyline([
                        fromMarker.getLatLng(),
                        toMarker.getLatLng()
                    ], {
                        color: '#f44336',
                        weight: 4,
                        opacity: 0.8
                    }).addTo(topologyMap);

                    highlightedPath.push(line);
                }
            }
        }

        // Refresh topology data and fit to all nodes
        async function refreshTopology() {
            document.getElementById('mapStatus').textContent = 'Loading...';
            const data = await loadTopologyData();
            if (data) {
                renderTopology(data);

                // Fit map to show all nodes after refresh
                const bounds = [];
                data.nodes.forEach(node => {
                    if (node.lat && node.lon && node.lat !== '' && node.lon !== '') {
                        const lat = parseFloat(node.lat);
                        const lon = parseFloat(node.lon);
                        if (!isNaN(lat) && !isNaN(lon)) {
                            bounds.push([lat, lon]);
                        }
                    }
                });

                if (bounds.length > 0) {
                    topologyMap.fitBounds(bounds, { padding: [50, 50] });
                }
            }
        }

        // Initialize topology map
        async function initTopologyMap() {
            initMap();
            await refreshTopology();

            // Set up button event listener
            document.getElementById('refreshMapBtn').addEventListener('click', refreshTopology);
        }

        // ============================================================
        // END TOPOLOGY MAP FUNCTIONALITY
        // ============================================================

        // Initialize page
        async function init() {
            // Load health status first (independent of test data)
            loadHealthStatus();

            // Set up periodic health updates (every 60 seconds)
            setInterval(loadHealthStatus, HEALTH_UPDATE_INTERVAL);

            // Initialize topology map (independent of test data)
            initTopologyMap();

            // Fetch test results data first (don't render yet)
            const response = await fetch('/cgi-bin/uac_test_db_json');
            const data = await response.json();

            // If no test data yet, show waiting message
            if (data.error || (data.num_results === 0 && data.num_testable_phones === 0)) {
                document.getElementById('testProgress').textContent = 'Waiting for first test cycle to complete...';
                document.getElementById('results').innerHTML =
                    '<tr><td colspan="8" class="loading">Waiting for first test cycle (runs every 60 seconds)...</td></tr>';
                return;
            }

            // Load phonebook before rendering anything
            await loadPhonebook(data.last_update || 0);

            // Now render results with phonebook data available
            await loadResults();

            // Update progress
            if (!data.error && data.num_results !== undefined) {
                updateProgress(data.num_results, data.num_testable_phones);
            }
        }

        // Run on page load
        init();
    </script>
EOF

# HTML Footer
cat <<'EOF'

    <br>
    <div class="info">
        <strong>Legend:</strong><br>
        <span class="online">● ONLINE</span> - Phone responded to test<br>
        <span class="offline">● OFFLINE</span> - Phone did not respond (DNS resolved but no response)<br>
        <span class="no-dns">● NO DNS</span> - Phone hostname does not resolve (node not on mesh)<br>
        <span class="disabled">● DISABLED</span> - Test disabled in configuration<br>
        <br>
        <strong>RTT Color Coding:</strong><br>
        <span class="rtt-good">● Green</span> - Good (&lt;100ms)<br>
        <span class="rtt-medium">● Orange</span> - Medium (100-200ms)<br>
        <span class="rtt-poor">● Red</span> - Poor (&gt;200ms)<br>
        <br>
        <strong>Note:</strong> Only phones with working DNS resolution are tested.<br>
        The phonebook is updated every hour. Total count reflects all registered phones in the phonebook.
    </div>
</body>
</html>
EOF
