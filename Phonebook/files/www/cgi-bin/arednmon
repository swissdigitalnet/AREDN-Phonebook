#!/bin/sh
# AREDNmon - AREDN Mesh Network Monitor
# Displays network monitoring results from automated bulk test cycles
# The bulk test runs automatically every UAC_TEST_INTERVAL_SECONDS (default: 600s)
# Usage: curl "http://node/cgi-bin/arednmon"

echo "Content-Type: text/html; charset=utf-8"
echo ""

# Get configuration
CONFIG_FILE="/etc/phonebook.conf"
TEST_INTERVAL=$(grep "^UAC_TEST_INTERVAL_SECONDS=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
TEST_INTERVAL=${TEST_INTERVAL:-60}

# HTML Header
cat <<'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>AREDNmon - Network Monitor</title>
    <meta http-equiv="refresh" content="30">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .info {
            background-color: #e7f3fe;
            border-left: 4px solid #2196F3;
            padding: 10px;
            margin-bottom: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        th {
            background-color: #4CAF50;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        td {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .online {
            color: #4CAF50;
            font-weight: bold;
        }
        .offline {
            color: #f44336;
            font-weight: bold;
        }
        .no-dns {
            color: #999;
        }
        .disabled {
            color: #999;
        }
        .rtt-good {
            color: #4CAF50;
        }
        .rtt-medium {
            color: #FF9800;
        }
        .rtt-poor {
            color: #f44336;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .error {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px;
            margin: 20px 0;
            color: #c62828;
        }
        .progress-container {
            background-color: #f0f0f0;
            border-radius: 8px;
            height: 30px;
            margin: 10px 0;
            overflow: hidden;
            position: relative;
        }
        .progress-bar {
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            height: 100%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            color: #333;
            z-index: 1;
        }
        /* Health Panel Styles */
        .health-panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .health-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .health-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
        }
        .health-score {
            font-size: 2em;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 8px;
        }
        .health-score.excellent { background-color: #4CAF50; color: white; }
        .health-score.good { background-color: #8BC34A; color: white; }
        .health-score.degraded { background-color: #FF9800; color: white; }
        .health-score.critical { background-color: #f44336; color: white; }
        .health-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .health-metric {
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        .health-metric-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        .health-metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
        .health-checks {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        .health-check {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .health-check.pass {
            background-color: #C8E6C9;
            color: #2E7D32;
        }
        .health-check.fail {
            background-color: #FFCDD2;
            color: #C62828;
        }
        .health-threads {
            margin-top: 15px;
            font-size: 0.9em;
        }
        .thread-status {
            display: inline-block;
            margin-right: 15px;
            padding: 3px 8px;
            border-radius: 3px;
        }
        .thread-status.responsive {
            background-color: #C8E6C9;
            color: #2E7D32;
        }
        .thread-status.unresponsive {
            background-color: #FFCDD2;
            color: #C62828;
        }
    </style>
</head>
<body>
    <h1>AREDNmon - Network Monitor</h1>
EOF

cat <<'EOF'
    <!-- Software Health Panel -->
    <div class="health-panel" id="healthPanel">
        <div class="health-header">
            <div class="health-title">Software Health Status</div>
            <div class="health-score" id="healthScore">Loading...</div>
        </div>
        <div class="health-metrics">
            <div class="health-metric">
                <div class="health-metric-label">CPU Usage</div>
                <div class="health-metric-value" id="healthCpu">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">Memory Usage</div>
                <div class="health-metric-value" id="healthMemory">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">Uptime</div>
                <div class="health-metric-value" id="healthUptime">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">SIP Service</div>
                <div class="health-metric-value" id="healthSipUsers">-</div>
            </div>
        </div>
        <div class="health-checks" id="healthChecks">
            <!-- Health checks will be populated by JavaScript -->
        </div>
        <div class="health-threads" id="healthThreads">
            <strong>Thread Status:</strong> <span id="threadStatus">Loading...</span>
        </div>
    </div>
EOF

cat <<EOF
    <div class="info" id="info">
        <strong>Automatic Testing:</strong> Tests run every $TEST_INTERVAL seconds<br>
        <strong>Last Update:</strong> <span id="lastUpdate">Loading...</span><br>
        <strong>Test Progress:</strong> <span id="testProgress">Loading...</span><br>
        <div class="progress-container">
            <div class="progress-text" id="progressText">0%</div>
            <div class="progress-bar" id="progressBar" style="width: 0%"></div>
        </div>
        <strong>Auto-refresh:</strong> This page refreshes every 30 seconds
    </div>

    <div id="errorContainer"></div>

    <table>
        <thead>
            <tr>
                <th>Phone Number</th>
                <th>Name</th>
                <th>Ping Status</th>
                <th>Ping RTT (ms)</th>
                <th>Ping Jitter (ms)</th>
                <th>OPTIONS Status</th>
                <th>OPTIONS RTT (ms)</th>
                <th>OPTIONS Jitter (ms)</th>
            </tr>
        </thead>
        <tbody id="results">
            <tr><td colspan="8" class="loading">Loading test results...</td></tr>
        </tbody>
    </table>

    <script>
        // Health data update interval (60 seconds to match local file updates)
        const HEALTH_UPDATE_INTERVAL = 60000;

        // Load and display software health
        async function loadHealthStatus() {
            try {
                const response = await fetch('/cgi-bin/health_status');
                const data = await response.json();

                if (data.error) {
                    document.getElementById('healthScore').textContent = 'N/A';
                    document.getElementById('healthScore').className = 'health-score';
                    return;
                }

                // Update health score
                const score = data.health_score || 0;
                const scoreElement = document.getElementById('healthScore');
                scoreElement.textContent = Math.round(score) + '/100';

                // Set score color based on thresholds
                if (score >= 85) {
                    scoreElement.className = 'health-score excellent';
                } else if (score >= 70) {
                    scoreElement.className = 'health-score good';
                } else if (score >= 50) {
                    scoreElement.className = 'health-score degraded';
                } else {
                    scoreElement.className = 'health-score critical';
                }

                // Update metrics
                document.getElementById('healthCpu').textContent =
                    (data.cpu_pct || 0).toFixed(1) + '%';
                document.getElementById('healthMemory').textContent =
                    (data.mem_mb || 0).toFixed(1) + ' MB';

                // Format uptime
                const uptimeSeconds = data.uptime_seconds || 0;
                const hours = Math.floor(uptimeSeconds / 3600);
                const minutes = Math.floor((uptimeSeconds % 3600) / 60);
                document.getElementById('healthUptime').textContent =
                    hours + 'h ' + minutes + 'm';

                // SIP service metrics
                const users = data.sip_service?.registered_users || 0;
                const entries = data.sip_service?.directory_entries || 0;
                const calls = data.sip_service?.active_calls || 0;
                document.getElementById('healthSipUsers').textContent =
                    users + ' users, ' + calls + ' calls';

                // Update health checks
                const checks = data.checks || {};
                const checksHtml = [
                    { label: 'Memory', pass: checks.memory_stable },
                    { label: 'No Crashes', pass: checks.no_recent_crashes },
                    { label: 'SIP Service', pass: checks.sip_service_ok },
                    { label: 'Phonebook', pass: checks.phonebook_current },
                    { label: 'CPU', pass: checks.cpu_normal }
                ].map(check =>
                    '<span class="health-check ' + (check.pass ? 'pass' : 'fail') + '">' +
                    check.label + ': ' + (check.pass ? '✓' : '✗') + '</span>'
                ).join('');
                document.getElementById('healthChecks').innerHTML = checksHtml;

                // Update thread status
                const threads = data.threads || {};
                const allResponsive = threads.all_responsive;
                let threadHtml = '';

                if (allResponsive) {
                    threadHtml = '<span class="thread-status responsive">All threads responsive ✓</span>';
                } else {
                    // Show individual thread status
                    const threadNames = ['phonebook_fetcher', 'status_updater', 'passive_safety',
                                       'uac_bulk_tester', 'health_reporter'];
                    threadHtml = threadNames
                        .filter(name => threads[name])
                        .map(name => {
                            const thread = threads[name];
                            const responsive = thread.responsive;
                            return '<span class="thread-status ' +
                                   (responsive ? 'responsive' : 'unresponsive') + '">' +
                                   name + ': ' + (responsive ? '✓' : '✗') + '</span>';
                        }).join('');
                }
                document.getElementById('threadStatus').innerHTML = threadHtml;

            } catch (error) {
                console.error('Failed to load health status:', error);
                document.getElementById('healthScore').textContent = 'Error';
                document.getElementById('healthScore').className = 'health-score';
            }
        }

        // Phonebook data (loaded from server)
        let phonebook = {};

        // Load phonebook data with smart caching
        async function loadPhonebook(lastTestUpdate) {
            try {
                // Check if phonebook cache exists (v2 - invalidates old caches after DB structure change)
                const cached = localStorage.getItem('phonebook_cache_v2');
                const cacheTestUpdate = localStorage.getItem('phonebook_cache_test_update_v2');

                // Invalidate cache if test database is newer (phonebook may have changed)
                const cacheValid = cached && cacheTestUpdate &&
                                   parseInt(cacheTestUpdate) >= lastTestUpdate;

                if (cacheValid) {
                    phonebook = JSON.parse(cached);
                    console.log('Using cached phonebook (' + Object.keys(phonebook).length + ' entries)');
                    return;
                }

                // Cache invalid or missing - fetch from server
                console.log('Fetching phonebook from server...');
                const response = await fetch('/cgi-bin/showphonebook');
                const data = await response.json();

                if (data.entries && data.entries.length > 0) {
                    data.entries.forEach(entry => {
                        // Extract phone number without @routing suffix
                        const phoneNumber = entry.telephone.split('@')[0];
                        phonebook[phoneNumber] = entry.name.trim();
                    });

                    // Save to localStorage cache with test database timestamp
                    localStorage.setItem('phonebook_cache_v2', JSON.stringify(phonebook));
                    localStorage.setItem('phonebook_cache_test_update_v2', lastTestUpdate.toString());
                    console.log('Cached phonebook (' + Object.keys(phonebook).length + ' entries) at test update ' + lastTestUpdate);
                }
            } catch (error) {
                console.error('Failed to load phonebook:', error);
            }
        }

        // Get display name for a phone number
        function getDisplayName(phoneNumber) {
            // Strip any @routing suffix from phone number
            const cleanNumber = phoneNumber.split('@')[0];
            return phonebook[cleanNumber] || phoneNumber;
        }

        // Get CSS class for status
        function getStatusClass(status) {
            if (status === 'ONLINE') return 'online';
            if (status === 'OFFLINE') return 'offline';
            if (status === 'NO_DNS' || status === 'NO DNS') return 'no-dns';
            if (status === 'DISABLED') return 'disabled';
            return '';
        }

        // Get CSS class for RTT
        function getRttClass(rtt) {
            if (rtt <= 0) return '';
            if (rtt > 200) return 'rtt-poor';
            if (rtt > 100) return 'rtt-medium';
            return 'rtt-good';
        }

        // Format RTT value
        function formatRtt(value) {
            if (value <= 0) return '-';
            return value.toFixed(2);
        }

        // Load and display test results
        async function loadResults() {
            try {
                const response = await fetch('/cgi-bin/uac_test_db_json');
                const data = await response.json();

                if (data.error) {
                    document.getElementById('errorContainer').innerHTML =
                        '<div class="error">Error: ' + data.error + '</div>';
                    document.getElementById('results').innerHTML =
                        '<tr><td colspan="8" class="loading">No test data available yet</td></tr>';
                    return data.last_update || 0;
                }

                // Update last update time
                if (data.last_update) {
                    const lastUpdate = new Date(data.last_update * 1000);
                    document.getElementById('lastUpdate').textContent = lastUpdate.toLocaleString();
                }

                // Return last_update timestamp for cache validation
                const lastUpdateTimestamp = data.last_update || 0;

                // Build table rows
                const tbody = document.getElementById('results');
                tbody.innerHTML = '';

                if (data.results && data.results.length > 0) {
                    data.results.forEach(result => {
                        const row = document.createElement('tr');
                        const displayName = getDisplayName(result.phone_number);

                        row.innerHTML =
                            '<td>' + result.phone_number + '</td>' +
                            '<td>' + displayName + '</td>' +
                            '<td class="' + getStatusClass(result.ping_status) + '">' + result.ping_status + '</td>' +
                            '<td class="' + getRttClass(result.ping_rtt) + '">' + formatRtt(result.ping_rtt) + '</td>' +
                            '<td>' + formatRtt(result.ping_jitter) + '</td>' +
                            '<td class="' + getStatusClass(result.options_status) + '">' + result.options_status + '</td>' +
                            '<td class="' + getRttClass(result.options_rtt) + '">' + formatRtt(result.options_rtt) + '</td>' +
                            '<td>' + formatRtt(result.options_jitter) + '</td>';

                        tbody.appendChild(row);
                    });
                } else {
                    tbody.innerHTML = '<tr><td colspan="8" class="loading">No test results available</td></tr>';
                }

                return lastUpdateTimestamp;
            } catch (error) {
                console.error('Failed to load results:', error);
                document.getElementById('errorContainer').innerHTML =
                    '<div class="error">Failed to load test results: ' + error.message + '</div>';
                document.getElementById('results').innerHTML =
                    '<tr><td colspan="8" class="loading">Error loading results</td></tr>';
                return 0;
            }
        }

        // Update progress indicator
        function updateProgress(numResults, numTestablePhones) {
            // Show progress only for reachable phones (those marked with * in phonebook)
            const reachablePhones = numTestablePhones || 0;
            const progressPct = reachablePhones > 0 ? Math.min(100, Math.round((numResults / reachablePhones) * 100)) : 0;

            document.getElementById('testProgress').textContent = numResults + ' of ' + reachablePhones + ' phones tested (all reachable telephones only)';
            document.getElementById('progressText').textContent = progressPct + '%';
            document.getElementById('progressBar').style.width = progressPct + '%';
        }

        // Initialize page
        async function init() {
            // Load health status first (independent of test data)
            loadHealthStatus();

            // Set up periodic health updates (every 60 seconds)
            setInterval(loadHealthStatus, HEALTH_UPDATE_INTERVAL);

            // Fetch test results data first (don't render yet)
            const response = await fetch('/cgi-bin/uac_test_db_json');
            const data = await response.json();

            // If no test data yet, show waiting message
            if (data.error || (data.num_results === 0 && data.num_testable_phones === 0)) {
                document.getElementById('testProgress').textContent = 'Waiting for first test cycle to complete...';
                document.getElementById('results').innerHTML =
                    '<tr><td colspan="8" class="loading">Waiting for first test cycle (runs every 60 seconds)...</td></tr>';
                return;
            }

            // Load phonebook before rendering anything
            await loadPhonebook(data.last_update || 0);

            // Now render results with phonebook data available
            await loadResults();

            // Update progress
            if (!data.error && data.num_results !== undefined) {
                updateProgress(data.num_results, data.num_testable_phones);
            }
        }

        // Run on page load
        init();
    </script>
EOF

# HTML Footer
cat <<'EOF'

    <br>
    <div class="info">
        <strong>Legend:</strong><br>
        <span class="online">● ONLINE</span> - Phone responded to test<br>
        <span class="offline">● OFFLINE</span> - Phone did not respond (DNS resolved but no response)<br>
        <span class="no-dns">● NO DNS</span> - Phone hostname does not resolve (node not on mesh)<br>
        <span class="disabled">● DISABLED</span> - Test disabled in configuration<br>
        <br>
        <strong>RTT Color Coding:</strong><br>
        <span class="rtt-good">● Green</span> - Good (&lt;100ms)<br>
        <span class="rtt-medium">● Orange</span> - Medium (100-200ms)<br>
        <span class="rtt-poor">● Red</span> - Poor (&gt;200ms)<br>
        <br>
        <strong>Note:</strong> Only phones with working DNS resolution are tested.<br>
        The phonebook is updated every hour. Total count reflects all registered phones in the phonebook.
    </div>
</body>
</html>
EOF
