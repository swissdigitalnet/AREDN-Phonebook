#!/bin/sh
# AREDNmon - AREDN Mesh Network Monitor
# Displays network monitoring results from automated bulk test cycles
# The bulk test runs automatically every UAC_TEST_INTERVAL_SECONDS (default: 600s)
# Usage: curl "http://node/cgi-bin/arednmon"

echo "Content-Type: text/html; charset=utf-8"
echo ""

# Get configuration
CONFIG_FILE="/etc/phonebook.conf"
TEST_INTERVAL=$(grep "^UAC_TEST_INTERVAL_SECONDS=" "$CONFIG_FILE" 2>/dev/null | cut -d'=' -f2)
TEST_INTERVAL=${TEST_INTERVAL:-60}

# HTML Header
cat <<'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>AREDNmon - Network Monitor</title>
    <meta http-equiv="refresh" content="30">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .info {
            background-color: #e7f3fe;
            border-left: 4px solid #2196F3;
            padding: 10px;
            margin-bottom: 20px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        th {
            background-color: #4CAF50;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        td {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .online {
            color: #4CAF50;
            font-weight: bold;
        }
        .offline {
            color: #f44336;
            font-weight: bold;
        }
        .no-dns {
            color: #999;
        }
        .disabled {
            color: #999;
        }
        .rtt-good {
            color: #4CAF50;
        }
        .rtt-medium {
            color: #FF9800;
        }
        .rtt-poor {
            color: #f44336;
        }
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .error {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px;
            margin: 20px 0;
            color: #c62828;
        }
        .progress-container {
            background-color: #f0f0f0;
            border-radius: 8px;
            height: 30px;
            margin: 10px 0;
            overflow: hidden;
            position: relative;
        }
        .progress-bar {
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            height: 100%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .progress-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 30px;
            font-weight: bold;
            color: #333;
            z-index: 1;
        }
        /* Health Panel Styles */
        .health-panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .health-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .health-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
        }
        .health-score {
            font-size: 2em;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 8px;
        }
        .health-score.excellent { background-color: #4CAF50; color: white; }
        .health-score.good { background-color: #8BC34A; color: white; }
        .health-score.degraded { background-color: #FF9800; color: white; }
        .health-score.critical { background-color: #f44336; color: white; }
        .health-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        .health-metric {
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
        }
        .health-metric-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }
        .health-metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #333;
        }
        .health-checks {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        .health-check {
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .health-check.pass {
            background-color: #C8E6C9;
            color: #2E7D32;
        }
        .health-check.fail {
            background-color: #FFCDD2;
            color: #C62828;
        }
        .health-threads {
            margin-top: 15px;
            font-size: 0.9em;
        }
        .thread-status {
            display: inline-block;
            margin-right: 15px;
            padding: 3px 8px;
            border-radius: 3px;
        }
        .thread-status.responsive {
            background-color: #C8E6C9;
            color: #2E7D32;
        }
        .thread-status.unresponsive {
            background-color: #FFCDD2;
            color: #C62828;
        }
        /* Map Panel Styles */
        .map-panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .map-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }
        #topologyMap {
            width: calc(100% - 120px);
            aspect-ratio: 21 / 9;
            margin: 0 60px;
            border-radius: 4px;
        }
        .map-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }
        .map-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        .map-btn:hover {
            background-color: #45a049;
        }
        .map-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .map-legend {
            margin-top: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 4px;
            font-size: 0.9em;
        }
        /* Traceroute Display Styles */
        .traceroute-panel {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        .traceroute-panel.visible {
            display: block;
        }
        .traceroute-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }
        .traceroute-content {
            font-family: monospace;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 4px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .traceroute-loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        .traceroute-hop {
            padding: 5px 0;
            border-bottom: 1px solid #ddd;
        }
        .traceroute-hop:last-child {
            border-bottom: none;
        }
        .traceroute-hop-number {
            display: inline-block;
            width: 40px;
            font-weight: bold;
            color: #2196F3;
        }
        .traceroute-hop-host {
            color: #333;
        }
        .traceroute-hop-rtt {
            color: #4CAF50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>AREDNmon - Network Monitor</h1>
EOF

cat <<'EOF'
    <!-- Software Health Panel -->
    <div class="health-panel" id="healthPanel">
        <div class="health-header">
            <div class="health-title">Software Health Status</div>
        </div>
        <div class="health-metrics">
            <div class="health-metric">
                <div class="health-metric-label">CPU Usage</div>
                <div class="health-metric-value" id="healthCpu">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">Memory Usage</div>
                <div class="health-metric-value" id="healthMemory">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">Uptime</div>
                <div class="health-metric-value" id="healthUptime">-</div>
            </div>
            <div class="health-metric">
                <div class="health-metric-label">SIP Service</div>
                <div class="health-metric-value" id="healthSipUsers">-</div>
            </div>
        </div>
        <div class="health-checks" id="healthChecks">
            <!-- Health checks will be populated by JavaScript -->
        </div>
        <div class="health-threads" id="healthThreads">
            <strong>Thread Status:</strong> <span id="threadStatus">Loading...</span>
        </div>
    </div>

    <!-- Network Topology Map -->
    <div class="map-panel" id="mapPanel">
        <div class="map-title">Network Topology Map</div>
        <div id="topologyMap"></div>
        <div class="map-controls">
            <button class="map-btn" id="refreshMapBtn">Refresh Topology</button>
            <span id="mapStatus" style="margin-left: 10px; color: #666;"></span>
        </div>
        <div class="map-legend">
            <strong>Connection Quality (RTT):</strong><br>
            <span style="color: #4CAF50;">━━━ Green</span> - Excellent (&lt;100ms)<br>
            <span style="color: #FF9800;">━━━ Orange</span> - Medium (100-200ms)<br>
            <span style="color: #f44336;">━━━ Red</span> - Poor (&gt;200ms)<br>
            <br>
            <strong>Interaction:</strong> Click any node to highlight the route and show traceroute results below
        </div>
    </div>

    <!-- Traceroute Panel -->
    <div class="traceroute-panel" id="traceroutePanel">
        <div class="traceroute-title" id="tracerouteTitle">Traceroute Results</div>
        <div class="traceroute-content" id="tracerouteContent">
            <div class="traceroute-loading">Click on a node to view traceroute</div>
        </div>
    </div>

    <!-- Debug: Topology Data Tables -->
    <div class="map-panel" id="debugPanel" style="margin-top: 20px;">
        <div class="map-title">Debug: Topology Data</div>

        <h3 style="margin-top: 15px; color: #333;">Nodes <span id="nodeCountHeader" style="color: #666; font-size: 0.9em;">(0 nodes)</span></h3>
        <div style="overflow-x: auto;">
            <table style="font-size: 0.85em;">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>IP</th>
                        <th>Type</th>
                        <th>Status</th>
                        <th>Latitude</th>
                        <th>Longitude</th>
                        <th>Grid Square</th>
                    </tr>
                </thead>
                <tbody id="debugNodesTable">
                    <tr><td colspan="7" class="loading">No topology data loaded</td></tr>
                </tbody>
            </table>
        </div>

        <h3 style="margin-top: 20px; color: #333;">Connections</h3>
        <div style="overflow-x: auto;">
            <table style="font-size: 0.85em;">
                <thead>
                    <tr>
                        <th>From Node</th>
                        <th>To Node</th>
                        <th>RTT Min (ms)</th>
                        <th>RTT Avg (ms)</th>
                        <th>RTT Max (ms)</th>
                    </tr>
                </thead>
                <tbody id="debugConnectionsTable">
                    <tr><td colspan="5" class="loading">No topology data loaded</td></tr>
                </tbody>
            </table>
        </div>
    </div>
EOF

cat <<EOF
    <div id="errorContainer"></div>

    <table>
        <thead>
            <tr>
                <th>Phone Number</th>
                <th>Name</th>
                <th>Ping Status</th>
                <th>Ping RTT (ms)</th>
                <th>Ping Jitter (ms)</th>
                <th>OPTIONS Status</th>
                <th>OPTIONS RTT (ms)</th>
                <th>OPTIONS Jitter (ms)</th>
            </tr>
        </thead>
        <tbody id="results">
            <tr><td colspan="8" class="loading">Loading test results...</td></tr>
        </tbody>
    </table>

    <script>
        // Health data update interval (60 seconds to match local file updates)
        const HEALTH_UPDATE_INTERVAL = 60000;
        // Topology data update interval (10 seconds for real-time node discovery)
        const TOPOLOGY_UPDATE_INTERVAL = 10000;
        // Track previously seen nodes to highlight new discoveries
        let previousNodeIPs = new Set();
        let newNodeHighlights = new Map(); // IP -> timestamp when added

        // Load and display software health
        async function loadHealthStatus() {
            try {
                const response = await fetch('/cgi-bin/health_status');
                const data = await response.json();

                if (data.error) {
                    return;
                }

                // Update metrics
                document.getElementById('healthCpu').textContent =
                    (data.cpu_pct || 0).toFixed(1) + '%';
                document.getElementById('healthMemory').textContent =
                    (data.mem_mb || 0).toFixed(1) + ' MB';

                // Format uptime
                const uptimeSeconds = data.uptime_seconds || 0;
                const hours = Math.floor(uptimeSeconds / 3600);
                const minutes = Math.floor((uptimeSeconds % 3600) / 60);
                document.getElementById('healthUptime').textContent =
                    hours + 'h ' + minutes + 'm';

                // SIP service metrics
                const users = data.sip_service?.registered_users || 0;
                const entries = data.sip_service?.directory_entries || 0;
                const calls = data.sip_service?.active_calls || 0;
                document.getElementById('healthSipUsers').textContent =
                    users + ' users, ' + calls + ' calls';

                // Update health checks
                const checks = data.checks || {};
                const checksHtml = [
                    { label: 'Memory', pass: checks.memory_stable },
                    { label: 'No Crashes', pass: checks.no_recent_crashes },
                    { label: 'SIP Service', pass: checks.sip_service_ok },
                    { label: 'Phonebook', pass: checks.phonebook_current },
                    { label: 'CPU', pass: checks.cpu_normal }
                ].map(check =>
                    '<span class="health-check ' + (check.pass ? 'pass' : 'fail') + '">' +
                    check.label + ': ' + (check.pass ? '✓' : '✗') + '</span>'
                ).join('');
                document.getElementById('healthChecks').innerHTML = checksHtml;

                // Update thread status
                const threads = data.threads || {};
                const allResponsive = threads.all_responsive;
                let threadHtml = '';

                if (allResponsive) {
                    threadHtml = '<span class="thread-status responsive">All threads responsive ✓</span>';
                } else {
                    // Show individual thread status
                    const threadNames = ['phonebook_fetcher', 'status_updater', 'passive_safety',
                                       'uac_bulk_tester', 'health_reporter'];
                    threadHtml = threadNames
                        .filter(name => threads[name])
                        .map(name => {
                            const thread = threads[name];
                            const responsive = thread.responsive;
                            return '<span class="thread-status ' +
                                   (responsive ? 'responsive' : 'unresponsive') + '">' +
                                   name + ': ' + (responsive ? '✓' : '✗') + '</span>';
                        }).join('');
                }
                document.getElementById('threadStatus').innerHTML = threadHtml;

            } catch (error) {
                console.error('Failed to load health status:', error);
            }
        }

        // Phonebook data (loaded from server)
        let phonebook = {};

        // Load phonebook data with smart caching
        async function loadPhonebook(lastTestUpdate) {
            try {
                // Check if phonebook cache exists (v2 - invalidates old caches after DB structure change)
                const cached = localStorage.getItem('phonebook_cache_v2');
                const cacheTestUpdate = localStorage.getItem('phonebook_cache_test_update_v2');

                // Invalidate cache if test database is newer (phonebook may have changed)
                const cacheValid = cached && cacheTestUpdate &&
                                   parseInt(cacheTestUpdate) >= lastTestUpdate;

                if (cacheValid) {
                    phonebook = JSON.parse(cached);
                    console.log('Using cached phonebook (' + Object.keys(phonebook).length + ' entries)');
                    return;
                }

                // Cache invalid or missing - fetch from server
                console.log('Fetching phonebook from server...');
                const response = await fetch('/cgi-bin/showphonebook');
                const data = await response.json();

                if (data.entries && data.entries.length > 0) {
                    data.entries.forEach(entry => {
                        // Extract phone number without @routing suffix
                        const phoneNumber = entry.telephone.split('@')[0];
                        phonebook[phoneNumber] = entry.name.trim();
                    });

                    // Save to localStorage cache with test database timestamp
                    localStorage.setItem('phonebook_cache_v2', JSON.stringify(phonebook));
                    localStorage.setItem('phonebook_cache_test_update_v2', lastTestUpdate.toString());
                    console.log('Cached phonebook (' + Object.keys(phonebook).length + ' entries) at test update ' + lastTestUpdate);
                }
            } catch (error) {
                console.error('Failed to load phonebook:', error);
            }
        }

        // Get display name for a phone number
        function getDisplayName(phoneNumber) {
            // Strip any @routing suffix from phone number
            const cleanNumber = phoneNumber.split('@')[0];
            return phonebook[cleanNumber] || phoneNumber;
        }

        // Get CSS class for status
        function getStatusClass(status) {
            if (status === 'ONLINE') return 'online';
            if (status === 'OFFLINE') return 'offline';
            if (status === 'NO_DNS' || status === 'NO DNS') return 'no-dns';
            if (status === 'DISABLED') return 'disabled';
            return '';
        }

        // Get CSS class for RTT
        function getRttClass(rtt) {
            if (rtt <= 0) return '';
            if (rtt > 200) return 'rtt-poor';
            if (rtt > 100) return 'rtt-medium';
            return 'rtt-good';
        }

        // Format RTT value
        function formatRtt(value) {
            if (value <= 0) return '-';
            return value.toFixed(2);
        }

        // Load and display test results
        async function loadResults() {
            try {
                const response = await fetch('/cgi-bin/uac_test_db_json');
                const data = await response.json();

                if (data.error) {
                    document.getElementById('errorContainer').innerHTML =
                        '<div class="error">Error: ' + data.error + '</div>';
                    document.getElementById('results').innerHTML =
                        '<tr><td colspan="8" class="loading">No test data available yet</td></tr>';
                    return data.last_update || 0;
                }

                // Note: last update time display removed (no DOM element for it)

                // Return last_update timestamp for cache validation
                const lastUpdateTimestamp = data.last_update || 0;

                // Build table rows
                const tbody = document.getElementById('results');
                tbody.innerHTML = '';

                if (data.results && data.results.length > 0) {
                    data.results.forEach(result => {
                        const row = document.createElement('tr');
                        const displayName = getDisplayName(result.phone_number);

                        row.innerHTML =
                            '<td>' + result.phone_number + '</td>' +
                            '<td>' + displayName + '</td>' +
                            '<td class="' + getStatusClass(result.ping_status) + '">' + result.ping_status + '</td>' +
                            '<td class="' + getRttClass(result.ping_rtt) + '">' + formatRtt(result.ping_rtt) + '</td>' +
                            '<td>' + formatRtt(result.ping_jitter) + '</td>' +
                            '<td class="' + getStatusClass(result.options_status) + '">' + result.options_status + '</td>' +
                            '<td class="' + getRttClass(result.options_rtt) + '">' + formatRtt(result.options_rtt) + '</td>' +
                            '<td>' + formatRtt(result.options_jitter) + '</td>';

                        tbody.appendChild(row);
                    });
                } else {
                    tbody.innerHTML = '<tr><td colspan="8" class="loading">No test results available</td></tr>';
                }

                return lastUpdateTimestamp;
            } catch (error) {
                console.error('Failed to load results:', error);
                document.getElementById('errorContainer').innerHTML =
                    '<div class="error">Failed to load test results: ' + error.message + '</div>';
                document.getElementById('results').innerHTML =
                    '<tr><td colspan="8" class="loading">Error loading results</td></tr>';
                return 0;
            }
        }

        // Progress indicator removed (no DOM elements for it)

        // ============================================================
        // TOPOLOGY MAP FUNCTIONALITY
        // ============================================================

        let topologyMap = null;
        let topologyData = null;
        let nodeMarkers = {};
        let connectionLines = [];
        let highlightedPath = [];
        let rttLabels = [];  // Store RTT label markers for zoom-dependent visibility

        // Fetch and display traceroute for a node
        async function fetchTraceroute(targetIp, targetName) {
            const panel = document.getElementById('traceroutePanel');
            const title = document.getElementById('tracerouteTitle');
            const content = document.getElementById('tracerouteContent');

            // Show panel
            panel.classList.add('visible');

            // Update title
            title.textContent = 'Traceroute to ' + targetName + ' (' + targetIp + ')';

            // Show loading
            content.innerHTML = '<div class="traceroute-loading">Running traceroute...</div>';

            try {
                const response = await fetch('/cgi-bin/traceroute_json?ip=' + encodeURIComponent(targetIp));
                const data = await response.json();

                if (data.error) {
                    content.innerHTML = '<div class="error">No active route: ' + data.error + '</div>';
                    return;
                }

                // Display hops
                if (!data.hops || data.hops.length === 0) {
                    content.innerHTML = '<div class="error">No active route: No hops found in traceroute</div>';
                    return;
                }

                // Check if all hops are timeouts (no route)
                const allTimeouts = data.hops.every(hop => hop.timeout);
                if (allTimeouts) {
                    content.innerHTML = '<div class="error">No active route: All hops timed out</div>';
                    return;
                }

                let html = '';
                data.hops.forEach(hop => {
                    if (hop.timeout) {
                        html += '<div class="traceroute-hop">' +
                               '<span class="traceroute-hop-number">' + hop.hop + '</span>' +
                               '<span class="traceroute-hop-host">* * * (timeout)</span>' +
                               '</div>';
                    } else {
                        html += '<div class="traceroute-hop">' +
                               '<span class="traceroute-hop-number">' + hop.hop + '</span>' +
                               '<span class="traceroute-hop-host">' + hop.hostname + ' (' + hop.ip + ')</span>  ' +
                               '<span class="traceroute-hop-rtt">' + hop.rtt_ms.toFixed(2) + ' ms</span>' +
                               '</div>';
                    }
                });

                content.innerHTML = html;

            } catch (error) {
                console.error('Failed to fetch traceroute:', error);
                content.innerHTML = '<div class="error">No active route: Failed to run traceroute (' + error.message + ')</div>';
            }
        }

        // Calculate distance between two lat/lon points using Haversine formula (returns km)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Update RTT label visibility based on zoom level
        function updateRttLabelsVisibility() {
            if (!topologyMap) return;

            const zoomLevel = topologyMap.getZoom();
            const showLabels = zoomLevel >= 10;  // Show labels when zoomed in to level 10+

            rttLabels.forEach(labelInfo => {
                const label = labelInfo.marker;
                // Always show if distance > 5km, otherwise zoom-dependent
                if (labelInfo.distance > 5 || showLabels) {
                    if (!topologyMap.hasLayer(label)) {
                        topologyMap.addLayer(label);
                    }
                } else {
                    if (topologyMap.hasLayer(label)) {
                        topologyMap.removeLayer(label);
                    }
                }
            });
        }

        // Initialize Leaflet map
        function initMap() {
            // Switzerland bounds: [45.8, 5.9] to [47.8, 10.5]
            const switzerlandBounds = [
                [45.8, 5.9],  // Southwest corner
                [47.8, 10.5]  // Northeast corner
            ];

            // Create map centered on Switzerland
            topologyMap = L.map('topologyMap', {
                maxBounds: switzerlandBounds,
                maxBoundsViscosity: 1.0  // Prevent panning outside bounds
            }).fitBounds(switzerlandBounds);

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 18,
                minZoom: 7  // Prevent zooming out beyond Switzerland
            }).addTo(topologyMap);

            // Add zoom event listener to show/hide RTT labels
            topologyMap.on('zoomend', updateRttLabelsVisibility);

            console.log('Topology map initialized');
        }

        // Load topology data from server
        async function loadTopologyData() {
            try {
                const response = await fetch('/cgi-bin/topology_json');
                const data = await response.json();

                if (data.error) {
                    document.getElementById('mapStatus').textContent = data.error;
                    console.log('No topology data available yet');
                    return null;
                }

                topologyData = data;
                document.getElementById('mapStatus').textContent =
                    data.statistics.total_nodes + ' nodes, ' +
                    data.statistics.total_connections + ' connections';

                console.log('Loaded topology:', data.statistics);
                return data;
            } catch (error) {
                console.error('Failed to load topology data:', error);
                document.getElementById('mapStatus').textContent = 'Error loading topology';
                return null;
            }
        }

        // Get color for node type and status
        function getNodeColor(type, status) {
            if (status === 'OFFLINE') {
                return '#9E9E9E';  // Grey for offline
            }
            switch (type) {
                case 'phone': return '#4CAF50';  // Green
                case 'router': return '#FF9800'; // Orange
                default: return '#9E9E9E';       // Gray
            }
        }

        // Get icon for node type and status with optional highlight for new nodes
        function getNodeIcon(type, status, isNew) {
            const color = getNodeColor(type, status);
            const borderColor = isNew ? '#FFD700' : 'white';  // Gold border for new nodes
            const borderWidth = isNew ? '3px' : '2px';
            const pulseAnimation = isNew ? 'animation: pulse 1s ease-in-out infinite;' : '';
            return L.divIcon({
                className: 'custom-div-icon',
                html: '<style>@keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }</style>' +
                      '<div style="background-color:' + color + '; width: 12px; height: 12px; border-radius: 50%; ' +
                      'border: ' + borderWidth + ' solid ' + borderColor + '; ' + pulseAnimation + '"></div>',
                iconSize: [16, 16],
                iconAnchor: [8, 8]
            });
        }

        // Update debug tables with topology data
        function updateDebugTables(data) {
            if (!data) return;

            // Update nodes table
            const nodesTable = document.getElementById('debugNodesTable');
            if (data.nodes && data.nodes.length > 0) {
                // Update node count header
                document.getElementById('nodeCountHeader').textContent = '(' + data.nodes.length + ' nodes)';

                let html = '';
                data.nodes.forEach(node => {
                    const hasLocation = node.lat && node.lon && node.lat !== '' && node.lon !== '';
                    const rowStyle = hasLocation ? '' : ' style="background-color: #ffe0e0;"';

                    // For phones without location, show phone number in latitude column
                    let latDisplay = node.lat || '<em>missing</em>';
                    if (!hasLocation && node.type === 'phone') {
                        // Extract phone number from node name (typically ends with phone number)
                        const nameParts = node.name.split(' ');
                        const lastPart = nameParts[nameParts.length - 1];
                        // Check if last part looks like a phone number (contains digits)
                        if (/\d/.test(lastPart)) {
                            latDisplay = '<em>' + lastPart + '</em>';
                        } else {
                            latDisplay = '<em>' + node.name + '</em>';
                        }
                    }

                    html += '<tr' + rowStyle + '>' +
                           '<td>' + (node.name || '-') + '</td>' +
                           '<td>' + (node.ip || '-') + '</td>' +
                           '<td>' + (node.type || '-') + '</td>' +
                           '<td>' + (node.status || '-') + '</td>' +
                           '<td>' + latDisplay + '</td>' +
                           '<td>' + (node.lon || '<em>missing</em>') + '</td>' +
                           '<td>' + (node.grid_square || '-') + '</td>' +
                           '</tr>';
                });
                nodesTable.innerHTML = html;
            } else {
                nodesTable.innerHTML = '<tr><td colspan="7" class="loading">No nodes found</td></tr>';
                document.getElementById('nodeCountHeader').textContent = '(0 nodes)';
            }

            // Update connections table
            const connectionsTable = document.getElementById('debugConnectionsTable');
            if (data.connections && data.connections.length > 0) {
                let html = '';
                data.connections.forEach(conn => {
                    // Find node names for from and to IPs
                    const fromNode = data.nodes.find(n => n.ip === conn.from);
                    const toNode = data.nodes.find(n => n.ip === conn.to);
                    const fromName = fromNode ? fromNode.name : conn.from;
                    const toName = toNode ? toNode.name : conn.to;

                    html += '<tr>' +
                           '<td>' + fromName + '</td>' +
                           '<td>' + toName + '</td>' +
                           '<td>' + (conn.rtt_min_ms ? conn.rtt_min_ms.toFixed(1) : '-') + '</td>' +
                           '<td>' + (conn.rtt_avg_ms ? conn.rtt_avg_ms.toFixed(1) : '-') + '</td>' +
                           '<td>' + (conn.rtt_max_ms ? conn.rtt_max_ms.toFixed(1) : '-') + '</td>' +
                           '</tr>';
                });
                connectionsTable.innerHTML = html;
            } else {
                connectionsTable.innerHTML = '<tr><td colspan="5" class="loading">No connections found</td></tr>';
            }
        }

        // Render topology on map
        function renderTopology(data) {
            if (!topologyMap || !data) {
                return;
            }

            // Update debug tables
            updateDebugTables(data);

            // Clear existing markers, lines, and RTT labels
            Object.values(nodeMarkers).forEach(marker => topologyMap.removeLayer(marker));
            connectionLines.forEach(line => topologyMap.removeLayer(line));
            rttLabels.forEach(labelInfo => {
                if (topologyMap.hasLayer(labelInfo.marker)) {
                    topologyMap.removeLayer(labelInfo.marker);
                }
            });
            nodeMarkers = {};
            connectionLines = [];
            rttLabels = [];

            // Find map bounds
            let bounds = [];

            // Detect new nodes
            const currentNodeIPs = new Set();
            const now = Date.now();

            // Clean up old highlights (older than 30 seconds)
            for (const [ip, timestamp] of newNodeHighlights.entries()) {
                if (now - timestamp > 30000) {
                    newNodeHighlights.delete(ip);
                }
            }

            // Add nodes
            data.nodes.forEach(node => {
                currentNodeIPs.add(node.ip);

                // Check if this is a new node
                const isNewNode = !previousNodeIPs.has(node.ip);
                if (isNewNode) {
                    newNodeHighlights.set(node.ip, now);
                    console.log('New node discovered:', node.name, '(' + node.ip + ')');
                }

                // Skip nodes without location
                if (!node.lat || !node.lon || node.lat === '' || node.lon === '') {
                    return;
                }

                const lat = parseFloat(node.lat);
                const lon = parseFloat(node.lon);

                if (isNaN(lat) || isNaN(lon)) {
                    return;
                }

                bounds.push([lat, lon]);

                // Clean up node name (remove hostname prefix like "mid2.")
                let cleanName = node.name;
                if (cleanName.includes('.')) {
                    const parts = cleanName.split('.');
                    // If first part looks like hostname prefix (lowercase, short), remove it
                    if (parts.length > 1 && parts[0].length < 8 && parts[0] === parts[0].toLowerCase()) {
                        cleanName = parts.slice(1).join('.');
                    }
                }

                // Create marker with highlight for new nodes
                const isHighlighted = newNodeHighlights.has(node.ip);
                const marker = L.marker([lat, lon], {
                    icon: getNodeIcon(node.type, node.status, isHighlighted),
                    title: cleanName
                }).addTo(topologyMap);

                // Add simple popup with just the name
                marker.bindPopup('<strong>' + cleanName + '</strong>');

                // Add click handler for route highlighting and traceroute
                marker.on('click', async function() {
                    await highlightPathToNode(data, node.ip, cleanName);
                    // fetchTraceroute is now called from highlightPathToNode if needed
                });

                nodeMarkers[node.ip] = marker;
            });

            // Update the set of previously seen nodes
            previousNodeIPs = currentNodeIPs;

            // Get color for RTT (same as table color coding)
            function getRttColor(rtt) {
                if (rtt > 200) return '#f44336';  // Red - poor
                if (rtt > 100) return '#FF9800';  // Orange - medium
                return '#4CAF50';                  // Green - good
            }

            // Add connections with color coding and labels
            data.connections.forEach(conn => {
                const fromMarker = nodeMarkers[conn.from];
                const toMarker = nodeMarkers[conn.to];

                if (fromMarker && toMarker) {
                    const color = getRttColor(conn.rtt_avg_ms);

                    const line = L.polyline([
                        fromMarker.getLatLng(),
                        toMarker.getLatLng()
                    ], {
                        color: color,
                        weight: 3,
                        opacity: 0.7
                    }).addTo(topologyMap);

                    // Add tooltip with RTT info (on hover)
                    line.bindTooltip(
                        'RTT: ' + conn.rtt_avg_ms.toFixed(1) + ' ms' +
                        ' (min: ' + conn.rtt_min_ms.toFixed(1) +
                        ', max: ' + conn.rtt_max_ms.toFixed(1) + ')',
                        { sticky: true, permanent: false }
                    );

                    // Find node types and names for from and to
                    const fromNode = data.nodes.find(n => n.ip === conn.from);
                    const toNode = data.nodes.find(n => n.ip === conn.to);

                    // Add click handler to show connection details
                    line.on('click', function() {
                        // Clean up node names
                        let fromName = fromNode ? fromNode.name : conn.from;
                        let toName = toNode ? toNode.name : conn.to;

                        if (fromName.includes('.')) {
                            const parts = fromName.split('.');
                            if (parts.length > 1 && parts[0].length < 8 && parts[0] === parts[0].toLowerCase()) {
                                fromName = parts.slice(1).join('.');
                            }
                        }

                        if (toName.includes('.')) {
                            const parts = toName.split('.');
                            if (parts.length > 1 && parts[0].length < 8 && parts[0] === parts[0].toLowerCase()) {
                                toName = parts.slice(1).join('.');
                            }
                        }

                        // Create popup content
                        const popupContent = '<div style="font-family: Arial, sans-serif;">' +
                            '<strong>Connection Details</strong><br><br>' +
                            '<strong>From:</strong> ' + fromName + '<br>' +
                            '<strong>To:</strong> ' + toName + '<br><br>' +
                            '<strong>RTT Statistics:</strong><br>' +
                            '• Minimum: ' + conn.rtt_min_ms.toFixed(1) + ' ms<br>' +
                            '• Average: ' + conn.rtt_avg_ms.toFixed(1) + ' ms<br>' +
                            '• Maximum: ' + conn.rtt_max_ms.toFixed(1) + ' ms<br>' +
                            '</div>';

                        // Show popup at click location
                        L.popup()
                            .setLatLng(line.getCenter())
                            .setContent(popupContent)
                            .openOn(topologyMap);
                    });

                    // Only show RTT label for router-to-router connections
                    const isRouterToRouter = fromNode && toNode &&
                                            fromNode.type === 'router' && toNode.type === 'router';

                    if (isRouterToRouter) {
                        // Calculate distance between nodes
                        const fromLatLng = fromMarker.getLatLng();
                        const toLatLng = toMarker.getLatLng();
                        const distance = calculateDistance(
                            fromLatLng.lat, fromLatLng.lng,
                            toLatLng.lat, toLatLng.lng
                        );

                        // Create RTT label at midpoint (will be shown/hidden based on zoom and distance)
                        const midpoint = [
                            (fromLatLng.lat + toLatLng.lat) / 2,
                            (fromLatLng.lng + toLatLng.lng) / 2
                        ];

                        const rttLabel = L.marker(midpoint, {
                            icon: L.divIcon({
                                className: 'rtt-label',
                                html: '<div style="background-color: white; padding: 2px 4px; border-radius: 3px; ' +
                                      'font-size: 10px; font-weight: bold; color: ' + color + '; ' +
                                      'border: 1px solid ' + color + ';">' +
                                      conn.rtt_avg_ms.toFixed(1) + 'ms</div>',
                                iconSize: [40, 20],
                                iconAnchor: [20, 10]
                            })
                        });

                        // Add tooltip showing full details on hover
                        rttLabel.bindTooltip(
                            '<strong>RTT Statistics:</strong><br>' +
                            '• Minimum: ' + conn.rtt_min_ms.toFixed(1) + ' ms<br>' +
                            '• Average: ' + conn.rtt_avg_ms.toFixed(1) + ' ms<br>' +
                            '• Maximum: ' + conn.rtt_max_ms.toFixed(1) + ' ms<br>' +
                            '• Distance: ' + distance.toFixed(1) + ' km',
                            { permanent: false, direction: 'top' }
                        );

                        // Store in array with distance info for zoom-dependent visibility
                        rttLabels.push({
                            marker: rttLabel,
                            distance: distance
                        });
                    }

                    connectionLines.push(line);
                }
            });

            // Don't auto-zoom on render (removed autozoom functionality)

            // Update RTT label visibility based on current zoom level
            updateRttLabelsVisibility();

            console.log('Rendered', Object.keys(nodeMarkers).length, 'nodes and',
                       connectionLines.length, 'connections');
        }

        // BFS to find shortest path
        function findShortestPath(data, targetIp) {
            if (!data || !data.source_node) {
                return [];
            }

            const sourceIp = data.source_node.ip;

            // Build adjacency list
            const graph = {};
            data.connections.forEach(conn => {
                if (!graph[conn.from]) graph[conn.from] = [];
                if (!graph[conn.to]) graph[conn.to] = [];
                graph[conn.from].push(conn.to);
                graph[conn.to].push(conn.from); // Bidirectional
            });

            // BFS
            const queue = [[sourceIp]];
            const visited = new Set([sourceIp]);

            while (queue.length > 0) {
                const path = queue.shift();
                const node = path[path.length - 1];

                if (node === targetIp) {
                    return path;
                }

                if (graph[node]) {
                    graph[node].forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push([...path, neighbor]);
                        }
                    });
                }
            }

            return []; // No path found
        }

        // Highlight path to specific node (with live traceroute fallback)
        async function highlightPathToNode(data, targetIp, targetName) {
            // Clear previous highlights
            highlightedPath.forEach(line => topologyMap.removeLayer(line));
            highlightedPath = [];

            // Find shortest path in topology database
            const path = findShortestPath(data, targetIp);

            if (path.length === 0) {
                console.log('No path found in topology database for', targetIp, '- triggering live traceroute');

                // Show traceroute panel with "no active route" message initially
                const panel = document.getElementById('traceroutePanel');
                const content = document.getElementById('tracerouteContent');
                panel.classList.add('visible');
                content.innerHTML = '<div class="error">No active route in topology database. Running live traceroute...</div>';

                // Trigger live traceroute
                await fetchTraceroute(targetIp, targetName);
                return;
            }

            console.log('Path to', targetIp, ':', path);

            // Draw highlighted path with thicker, brighter line
            for (let i = 0; i < path.length - 1; i++) {
                const fromMarker = nodeMarkers[path[i]];
                const toMarker = nodeMarkers[path[i + 1]];

                if (fromMarker && toMarker) {
                    const line = L.polyline([
                        fromMarker.getLatLng(),
                        toMarker.getLatLng()
                    ], {
                        color: '#FF0000',
                        weight: 6,
                        opacity: 0.9,
                        dashArray: '10, 5'  // Dashed line for visibility
                    }).addTo(topologyMap);

                    // Bring to front to ensure visibility
                    line.bringToFront();

                    highlightedPath.push(line);
                }
            }
        }

        // Refresh topology data (without auto-zoom)
        async function refreshTopology() {
            document.getElementById('mapStatus').textContent = 'Loading...';
            const data = await loadTopologyData();
            if (data) {
                renderTopology(data);
            }
        }

        // Initialize topology map
        async function initTopologyMap() {
            initMap();
            await refreshTopology();

            // Set up button event listener
            document.getElementById('refreshMapBtn').addEventListener('click', refreshTopology);

            // Set up periodic topology updates (every 10 seconds for real-time discovery)
            setInterval(async function() {
                const data = await loadTopologyData();
                if (data) {
                    renderTopology(data);
                }
            }, TOPOLOGY_UPDATE_INTERVAL);
        }

        // ============================================================
        // END TOPOLOGY MAP FUNCTIONALITY
        // ============================================================

        // Initialize page
        async function init() {
            // Load health status first (independent of test data)
            loadHealthStatus();

            // Set up periodic health updates (every 60 seconds)
            setInterval(loadHealthStatus, HEALTH_UPDATE_INTERVAL);

            // Initialize topology map (independent of test data)
            initTopologyMap();

            // Fetch test results data first (don't render yet)
            const response = await fetch('/cgi-bin/uac_test_db_json');
            const data = await response.json();

            // If no test data yet, show waiting message
            if (data.error || (data.num_results === 0 && data.num_testable_phones === 0)) {
                document.getElementById('results').innerHTML =
                    '<tr><td colspan="8" class="loading">Waiting for first test cycle (runs every 60 seconds)...</td></tr>';
                return;
            }

            // Load phonebook before rendering anything
            await loadPhonebook(data.last_update || 0);

            // Now render results with phonebook data available
            await loadResults();
        }

        // Run on page load
        init();
    </script>
EOF

# HTML Footer
cat <<'EOF'

    <br>
    <div class="info">
        <strong>Legend:</strong><br>
        <span class="online">● ONLINE</span> - Phone responded to test<br>
        <span class="offline">● OFFLINE</span> - Phone did not respond (DNS resolved but no response)<br>
        <span class="no-dns">● NO DNS</span> - Phone hostname does not resolve (node not on mesh)<br>
        <span class="disabled">● DISABLED</span> - Test disabled in configuration<br>
        <br>
        <strong>RTT Color Coding:</strong><br>
        <span class="rtt-good">● Green</span> - Good (&lt;100ms)<br>
        <span class="rtt-medium">● Orange</span> - Medium (100-200ms)<br>
        <span class="rtt-poor">● Red</span> - Poor (&gt;200ms)<br>
        <br>
        <strong>Note:</strong> Only phones with working DNS resolution are tested.<br>
        The phonebook is updated every hour. Total count reflects all registered phones in the phonebook.
    </div>
</body>
</html>
EOF
